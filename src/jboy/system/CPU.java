package jboy.system;

import java.util.HashMap;

/**
 * <h3>Description</h3>
 * <h5>The GameBoy uses a chip that's a cross between the Intel 8080 and the Zilog Z80. The chip is the Sharp LR35902.</h5>
 *
 * <hr/>
 * <h3>Information about the CPU</h3>
 * <ul>
 *     <li>Number of instructions: 500</li>
 *     <li>
 *         Registers
 *         <ul>
 *             <li>8-bit: A, B, C, D, E, F, H, L</li>
 *             <li>16-bit: AF, BC, DE, HL, SP, PC</li>
 *         </ul>
 *     </li>
 *     <li>Clock speed: 4.194304 MHz (4.19 MHz)</li>
 * </ul>
 *
 * <hr/>
 * <h3>A few notes on the CPU:</h3>
 * <ul>
 *     <li>Official Nintendo documents refer to "machine cycles" when describing instructions.</li>
 *     <li>One machine cycle equals four CPU clock cycles.</li>
 *     <li>The numerical value of a machine cycle is 1.048576 MHz (1.05 MHz)</li>
 * </ul>
 *
 * <hr/>
 * <h3>A few notes on the registers:</h3>
 * <ul>
 *     <li>The F register is indirectly accessible by the programmer, and is used to store the results of various math operations.</li>
 *     <li>The PC register points to the next instruction to be executed in memory.</li>
 *     <li>The SP register points to the current stack position.</li>
 *     <li>
 *         The F register consists of the following:
 *         <ul>
 *             <li>Zero flag (Z, 7th bit): This bit is set when the result of a math operation is zero or two values match when using the CP instruction.</li>
 *             <li>Subtract flag (N, 6th bit): This bit is set if a subtraction was performed in the last math instruction regardless of result..</li>
 *             <li>Half carry flag (H, 5th bit): This bit is set if a carry occurred from the lower nibble in the last math operation.</li>
 *             <li>Carry flag (C, 4th bit): This bit is set when an operation results in carrying from or borrowing to the 7th bit.</li>
 *         </ul>
 *     </li>
 *     <li>
 *         On power up, the PC is initialized to 0x100 and the instruction at that location in the ROM is executed.
 *         From here on the PC is controlled indirectly by the instructions themselves that were generated by the programmer of the ROM cart.
 *     </li>
 *     <li>
 *         The SP is used to keep track of the top of the stack.
 *         <ul>
 *             <li>The Stack is used for saving variables, saving return addressed, passing arguments to subroutines and various other uses.</li>
 *             <li>The instructions CALL, PUSH and RST all put information onto the stack.</li>
 *             <li>The instructions POP, RET and RETI all take information off of the stack.</li>
 *             <li>Interrupts put a return address on the stack and remove it at the completion as well.</li>
 *             <li>
 *                 As information is put onto the stack, the stack grows DOWNWARD in RAM. As a result SP should always be initialized at the highest location of RAM space that has been allocated for use by the stack.
 *                 <ul>
 *                     <li>
 *                         For example, if a programmer wants to locate the SP at the top of low RAM space (0xC000 - 0xDFFF) he would set SP to 0xE000 using LD SP,0xE000.
 *                         (The SP automatically decrements before it puts something onto the stack, so it is perfectly acceptable to assign it a value which points to a memory address which is one location past the end of available RAM.)
 *                     </li>
 *                     <li>The SP is initialized to 0xFFFE on power up, but a programmer should not rely on this setting and should explicitly set its value.</li>
 *                 </ul>
 *             </li>
 *         </ul>
 *     </li>
 * </ul>
 */
public class CPU {
    // Value of the Zero flag is 0b10000000
    public static final int FLAG_ZERO = 0x80;

    // Value of the Subtract flag is 0b01000000
    public static final int FLAG_SUB = 0x40;

    // Value of the Half Carry flag is 0b00100000
    public static final int FLAG_HALF = 0x20;

    // Value of the Carry flag is 0b00010000
    public static final int FLAG_CARRY = 0x10;

    private int A;
    private int B;
    private int C;
    private int D;
    private int E;
    private int F;
    private int H;
    private int L;
    private int SP;
    private int PC;

    private final Memory memory;
    private final HashMap<Integer, Instruction> instructions;

    public CPU(Memory memory) {
        this.instructions = new Instructions(this);
        this.memory = memory;
        this.setAF(0x01B0);
        this.setBC(0x0013);
        this.setDE(0x00D8);
        this.setHL(0x014D);
        this.setSP(0xFFFE);
        this.setPC(0x100);
    }

    public int getA() {
        return this.A;
    }

    public int getB() {
        return this.B;
    }

    public int getC() {
        return this.C;
    }

    public int getD() {
        return this.D;
    }

    public int getE() {
        return this.E;
    }

    public int getF() {
        return this.F;
    }

    public int getH() {
        return this.H;
    }

    public int getL() {
        return this.L;
    }

    public int getAF() {
        return (this.A << 8) + this.F;
    }

    public int getBC() {
        return (this.B << 8) + this.C;
    }

    public int getDE() {
        return (this.D << 8) + this.E;
    }

    public int getHL() {
        return (this.H << 8) + this.L;
    }

    public void setA(int n) {
        this.A = n;
    }

    public void setB(int n) {
        this.B = n;
    }

    public void setC(int n) {
        this.C = n;
    }

    public void setD(int n) {
        this.D = n;
    }

    public void setE(int n) {
        this.E = n;
    }

    public void setF(int n) {
        this.F = (n & 0xF0);
    }

    public void setH(int n) {
        this.H = n;
    }

    public void setL(int n) {
        this.L = n;
    }

    public void setAF(int n) {
        this.A = (n & 0xFF00) >> 8;
        this.F = n & 0x00FF;
    }

    public void setBC(int n) {
        this.B = (n & 0xFF00) >> 8;
        this.C = n & 0x00FF;
    }

    public void setDE(int n) {
        this.D = (n & 0xFF00) >> 8;
        this.E = n & 0x00FF;
    }

    public void setHL(int n) {
        this.H = (n & 0xFF00) >> 8;
        this.L = n & 0x00FF;
    }

    public int getSP() {
        return this.SP;
    }

    public int getPC() {
        return this.PC;
    }

    public void setPC(int n) {
        this.PC = n;
    }

    public void setSP(int n) {
        this.SP = n;
    }

    /**
     * Tick one clock cycle
     */
    public void tick() {
        Instruction instruction = this.getInstruction(this.memory.getByteAt(this.PC++));
        this.execute(instruction);
    }

    private void incrementPC(int n) {
        this.PC += n;
    }

    /**
     * Fetches the current instruction.
     * @param opCode The op code to fetch.
     * @return The instruction to be executed.
     */
    private Instruction getInstruction(int opCode) {
        // Check if the op code is an 8-bit operation.
        if(opCode != 0xCB) {
            return this.instructions.get(opCode);
        } else {
            // The code is a 16-bit operation, so we need to combine the current op code and the next one in memory
            // to get the full op code.
            int code = this.combineBytes(opCode, this.memory.getByteAt(this.PC));
            return this.instructions.get(code);
        }
    }

    /**
     * Execute the {@link Instruction instruction}.
     * @param instruction The instruction to execute.
     */
    private void execute(Instruction instruction) {
        switch(instruction.getOpSize()) {
            case 1:
                instruction.getOperation().apply(null);
                break;
            case 2:
                instruction.getOperation().apply(this.getNextByte());
                break;
            case 3:
                instruction.getOperation().apply(this.getNext2Bytes());
                break;
        }

        this.incrementPC(instruction.getOpSize());
    }

    /**
     * Get the next byte from memory.
     * @return The next byte in memory as an array.
     */
    private int[] getNextByte() {
        return new int[] { this.memory.getByteAt(this.PC) };
    }

    /**
     * Get the next 2 bytes from memory. The GameBoy is Little Endian so the high byte and the low byte
     * are the second and first bytes from the current location, respectively.
     * @return The next byte in memory as an array.
     */
    private int[] getNext2Bytes() {
        return new int[] { this.memory.getByteAt(this.PC + 1), this.memory.getByteAt(this.PC) };
    }

    /**
     * Combines two bytes. Example, 0xC0 + 0xDE = 0xC0DE
     * @param highByte The value that the upper byte should equal.
     * @param lowByte The value that the lower byte should equal.
     * @return The sum of the bytes.
     */
    private int combineBytes(int highByte, int lowByte) {
        return (highByte << 8) + lowByte;
    }

    /**
     * Sets flags in the F register. If multiple flags should be set, then they should be bitwise or'd together.
     * Example: if Z and H should be set, then they should be passed in to this method like this: Z | H
     * @param flags The flags to check.
     */
    public void setFlags(int flags) {
        this.F = this.F | flags;
    }

    /**
     * Resets flags in the F register. If multiple flags should be reset, then they should be bitwise or'd together.
     * Example: if Z and H should be reset, then they should be passed in to this method like this: Z | H
     * @param flags The flags to check.
     */
    public void resetFlags(int flags) {
        this.F = this.F & ~flags;
    }

    /**
     * Checks if flags are set. If multiple flags should be queried, then they should bitwise or'd together.
     * Example: if Z and H should be reset, then they should be passed in to this method like this: Z | H
     * @param flags The flags to check.
     * @return True if the all flags are set, false if at least one flag is not set.
     */
    public boolean areFlagsSet(int flags) {
        return (this.F & flags) == flags;
    }

    /**
     * Increments a {@code value} by 1 and sets the necessary flags.
     * @param value The value to increment.
     * @return The incremented value.
     */
    private int increment(int value) {
        // FLAG_HALF - set if there was a carry from the 3rd bit to the 4th bit, otherwise reset.
        if((value & 0x0F) == 0x0F) {
            this.setFlags(FLAG_HALF);
        } else {
            this.resetFlags(FLAG_HALF);
        }

        // increment value by 1 and get the first 8 bits
        value = (value + 1) & 0xFF;

        // FLAG_SUB - reset
        this.resetFlags(FLAG_SUB);

        // FLAG_ZERO - set if result is 0, otherwise reset
        if(value == 0) {
            this.setFlags(FLAG_ZERO);
        } else {
            this.resetFlags(FLAG_ZERO);
        }

        return value;
    }

    /**
     * Decrements a {@code value} by 1 and sets the necessary flags.
     * @param value The value to decrement.
     * @return The decremented value.
     */
    private int decrement(int value) {
        // decrement value by 1 and get the first 8 bits
        int result = (value - 1) & 0xFF;

        // FLAG_HALF - set if there was a carry (borrow) from the 4th bit to the 3rd bit, otherwise reset.
        // invert value's bits, xor with (value - 1) then find out what the 4th bit is with (& 0x10).
        // If it equals zero, then there was a carry.
        if((((~value) ^ (result)) & 0x10) == 0) {
            this.setFlags(FLAG_HALF);
        } else {
            this.resetFlags(FLAG_HALF);
        }

        value = result;

        // FLAG_SUB - set
        this.setFlags(FLAG_SUB);

        // FLAG_ZERO - set if result is 0, otherwise reset
        if(value == 0) {
            this.setFlags(FLAG_ZERO);
        } else {
            this.resetFlags(FLAG_ZERO);
        }

        return value;
    }

    /**
     * Adds two 16-bit numbers together and sets the necessary flags.
     * @param num1 The first number.
     * @param num2 The second number.
     * @return The 16-bit result of the addition.
     */
    private int add16Bit(int num1, int num2) {
        int result = num1 + num2;

        if((result & 0xFFFF0000) != 0) {
            this.setFlags(FLAG_CARRY);
        } else {
            this.resetFlags(FLAG_CARRY);
        }

        if(((result & 0x0F) + (num2 & 0x0F)) > 0x0F) {
            this.setFlags(FLAG_HALF);
        } else {
            this.resetFlags(FLAG_HALF);
        }

        this.resetFlags(FLAG_SUB);
        return result & 0xFFFF;
    }

    /**
     * Adds two 8-bit numbers together and sets the necessary flags.
     * @param num1 The first number.
     * @param num2 The second number.
     * @return The 8-bit result of the addition.
     */
    private int add8Bit(int num1, int num2) {
        int result = num1 + num2;

        if((result & 0xFF00) != 0) {
            this.setFlags(FLAG_CARRY);
        } else {
            this.resetFlags(FLAG_CARRY);
        }

        if((result & 0xFF) != 0) {
            this.resetFlags(FLAG_ZERO);
        } else {
            this.setFlags(FLAG_ZERO);
        }

        if(((result & 0x0F) + (num2 & 0x0F)) > 0x0F) {
            this.setFlags(FLAG_HALF);
        } else {
            this.resetFlags(FLAG_CARRY);
        }

        this.resetFlags(FLAG_SUB);
        return result & 0xFF;
    }

    /**
     * OP codes 0x00, 0xD3, 0xDB, 0xDD, 0xE3, 0xE4, 0xEB, 0xEC, 0xED, 0xF4, 0xFC, 0xFD - No operation.
     * @param ops unused
     */
    Void nop(int[] ops) {
        // nothing.
        return null;
    }

    /**
     * OP code 0x01 - Load immediate 2 bytes into BC.
     * @param ops the two immediate 8 byte chunks.
     */
    Void ld_bc_xx(int[] ops) {
        this.setBC(this.combineBytes(ops[0], ops[1]));
        return null;
    }

    /**
     * OP code 0x02 - Load value of A into memory address at BC.
     * @param ops unused
     */
    Void ld_bcp_a(int[] ops) {
        this.memory.setByteAt(this.getBC(), this.A);
        return null;
    }

    /**
     * OP code 0x03 - Increment BC.
     * @param ops unused
     */
    Void inc_bc(int[] ops) {
        // increment BC by 1 and get the first 8 bits
        this.setBC((this.getBC() + 1) & 0xFF);
        return null;
    }

    /**
     * OP code 0x04 - Increment B.
     * @param ops unused
     */
    Void inc_b(int[] ops) {
        this.B = this.increment(this.B);
        return null;
    }

    /**
     * OP code 0x05 - Decrement B.
     * @param ops unused
     */
    Void dec_b(int[] ops) {
        this.B = this.decrement(this.B);
        return null;
    }

    /**
     * OP code 0x06 - Load immediate byte into B.
     * @param ops An 8 bit immediate value.
     */
    Void ld_b_x(int[] ops) {
        this.B = ops[0];
        return null;
    }

    /**
     * OP code 0x07 - Shift A left by 1 bit. Carry flag is set to the 7th bit of A.
     * @param ops unused
     */
    Void rlca(int[] ops) {
        int carry = (this.A & 0x80) >> 7;

        if(carry == 1) {
            this.setFlags(FLAG_CARRY);
        }

        // shift bit left by 1 and get the first 8 bits
        this.A = (this.A << 1) & 0xFF;

        // set the 0th bit to whatever was at the 7th bit.
        this.A = this.A | carry;

        this.resetFlags(FLAG_ZERO | FLAG_SUB | FLAG_HALF);
        return null;
    }

    /**
     * OP code 0x08 - Load value of SP into address at xx.
     * @param ops the two immediate 8 byte chunks.
     */
    Void ld_xxp_sp(int[] ops) {
        this.memory.setByteAt(this.combineBytes(ops[1], ops[0]), this.SP);
        return null;
    }

    /**
     * OP code 0x09 - Add the value of BC to HL.
     * @param ops unused
     */
    Void add_hl_bc(int[] ops) {
        // TODO: Flags are affected by this operation. Need to figure that out.
        this.setHL(this.getHL() + this.getBC());
        return null;
    }

    /**
     * OP code 0x0A - Load value at memory address BC into A.
     * @param ops unused.
     */
    Void ld_a_bcp(int[] ops) {
        this.A = this.memory.getByteAt(this.getBC());
        return null;
    }

    /**
     * OP code 0x0B - Decrement the value of BC.
     * @param ops unused.
     */
    Void dec_bc(int[] ops) {
        this.setBC(this.getBC() - 1);
        return null;
    }

    /**
     * OP code 0x0C - Increment the value of C.
     * @param ops unused.
     */
    Void inc_c(int[] ops) {
        this.C = this.increment(this.C);
        return null;
    }

    /**
     * OP code 0x0D - Decrement the value of C.
     * @param ops unused.
     */
    Void dec_c(int[] ops) {
        this.C = this.decrement(this.C);
        return null;
    }

    /**
     * OP code 0x0E - Load immediate byte into C.
     * @param ops An 8 bit immediate value.
     */
    Void ld_c_x(int[] ops) {
        this.C = ops[0];
        return null;
    }

    /**
     * OP code 0x0F - Shift A right by 1 bit. Carry flag is set to the 0th bit of A.
     * @param ops unused.
     */
    Void rrca(int[] ops) {
        int carry = this.A & 0x01;

        if(carry == 0x01) {
            this.setFlags(FLAG_CARRY);
        } else {
            this.resetFlags(FLAG_CARRY);
        }

        // set the 7th bit to whatever was at the 0th bit.
        // TODO: This might be right
        // https://www.geeksforgeeks.org/modify-bit-given-position/
        // (n & ~mask) | ((b << p) & mask)
        this.A = (((this.A >> 1) & (~0x80)) | (carry << 7)) & 0xFF;

        this.resetFlags(FLAG_ZERO | FLAG_SUB | FLAG_HALF);
        return null;
    }

    /**
     * OP code 0x10 - Enter CPU very low power mode.
     * - Execution of a STOP instruction stops both the system clock and oscillator circuit.
     * - STOP mode is entered, and the LCD controller also stops.
     * - However, the status of internal RAM register ports remains unchanged.
     * - STOP mode can be canceled by a reset signal.
     * - If the RESET terminal goes LOW in STOP mode, it becomes that of a normal reset status.
     * - The following conditions should be met before a STOP instruction is executed and STOP mode is entered:
     *   > All interrupt-enable (IE) flags are reset.
     *   > Input to P10 - P13 is LOW for all.
     * @param ops unused.
     */
    Void stop(int[] ops) {
        // TODO: figure out what to do with this.
        // I guess reset the IE flag, but how do I implement STOP in the CPU?
        // I think just a boolean, and check if it's set in the tick method.
        return null;
    }

    /**
     * OP code 0x11 - Load immediate 2 bytes into DE.
     * @param ops the two immediate 8 byte chunks.
     */
    Void ld_de_xx(int[] ops) {
        this.setDE(this.combineBytes(ops[0], ops[1]));
        return null;
    }

    /**
     * OP code 0x12 - Load the value of A in the memory address pointed to by DE.
     * @param ops unused.
     */
    Void ld_dep_a(int[] ops) {
        this.memory.setByteAt(this.getDE(), this.A);
        return null;
    }

    /**
     * OP code 0x13 - Increment DE.
     * @param ops unused
     */
    Void inc_de(int[] ops) {
        this.setDE(this.getDE() + 1);
        return null;
    }

    /**
     * OP code 0x14 - Increment the value of D.
     * @param ops unused.
     */
    Void inc_d(int[] ops) {
        this.D = this.increment(this.D);
        return null;
    }

    /**
     * OP code 0x15 - Decrement the value of D.
     * @param ops unused.
     */
    Void dec_d(int[] ops) {
        this.D = this.decrement(this.D);
        return null;
    }

    /**
     * OP code 0x16 - Load immediate byte into D.
     * @param ops An 8 bit immediate value.
     */
    Void ld_d_x(int[] ops) {
        this.D = ops[0];
        return null;
    }

    /**
     * OP code 0x17 - Shift A left by 1. The 0th bit of A is set to the value of the CARRY flag. CARRY flag is set to the 7th bit of A.
     * @param ops  unused.
     */
    Void rla(int[] ops) {
        // get current state of carry flag.
        int carry = this.F & FLAG_CARRY;

        // check the 7th bit of A.
        if((this.A & 0x80) == 0x80) {
            this.setFlags(FLAG_CARRY);
        } else {
            this.resetFlags(FLAG_CARRY);
        }

        // shift A left by 1 bit, change the 0th bit to whatever the carry flag was.
        this.A = (((this.A << 1) & (~0x01)) | carry) & 0xFF;

        // all other flags are reset.
        this.resetFlags(FLAG_ZERO | FLAG_SUB | FLAG_HALF);
        return null;
    }

    /**
     * OP code 0x18 - Increments PC by the amount of the next byte (between -128 and 127)
     * @param ops An 8 bit immediate value.
     */
    Void jr_x(int[] ops) {
        this.incrementPC((byte)ops[0]);

        // TODO: do I need to do this instead?
        /*if(ops[0] > 126) {
            this.incrementPC((ops[0] + 1) - 127);
        } else {
            this.incrementPC(ops[0] - 127);
        }*/

        return null;
    }

    /**
     * OP code 0x19 - Add HL and DE and store the result in HL.
     * @param ops unused.
     */
    Void add_hl_de(int[] ops) {
        this.setHL(this.add16Bit(this.getHL(), this.getDE()));
        return null;
    }

    /**
     * OP code 0x1A - Load the value memory address pointed to by DE into A.
     * @param ops unused.
     */
    Void ld_a_dep(int[] ops) {
        this.A = this.memory.getByteAt(this.getDE());
        return null;
    }

    /**
     * OP code 0x1B - Decrement DE by 1.
     * @param ops unused.
     */
    Void dec_de(int[] ops) {
        this.setDE(this.getDE() - 1);
        return null;
    }

    /**
     * OP code 0x1C - Increment E by 1.
     * @param ops unused.
     */
    Void inc_e(int[] ops) {
        this.E = this.increment(this.E);
        return null;
    }

    /**
     * OP code 0x1D - Decrement E by 1.
     * @param ops unused.
     */
    Void dec_e(int[] ops) {
        this.E = this.decrement(this.E);
        return null;
    }

    /**
     * OP code 0x1E - Load immediate byte into E.
     * @param ops An 8 bit immediate value.
     */
    Void ld_e_x(int[] ops) {
        this.E = ops[0];
        return null;
    }

    /**
     * OP code 0x1F - Shift A right by 1. The 7th bit of A is set to the value of the CARRY flag. CARRY flag is set the 0th bit of A.
     * @param ops unsued.
     */
    Void rra(int[] ops) {
        // get current state of carry flag.
        int carry = this.F & FLAG_CARRY;

        // check the 0th bit of A.
        if((this.A & 0x01) == 0x01) {
            this.setFlags(FLAG_CARRY);
        } else {
            this.resetFlags(FLAG_CARRY);
        }

        // shift A right by 1 bit, change the 7th bit to whatever the carry flag was.
        this.A = (((this.A >> 1) & (~0x80)) | (carry << 7)) & 0xFF;

        // all other flags are reset.
        this.resetFlags(FLAG_ZERO | FLAG_SUB | FLAG_HALF);
        return null;
    }

    /**
     * OP code 0x20 - Jump to given address relative to the current address if the zero flag is not set.
     * @param ops The 8-bit offset
     */
    Void jr_nz_x(int[] ops) {
        if((this.F & FLAG_ZERO) != FLAG_ZERO) {
            this.incrementPC((byte)ops[0]);

            // TODO: do I need to do this instead?
            /*if(ops[0] > 126) {
                this.incrementPC((ops[0] + 1) - 127);
            } else {
                this.incrementPC(ops[0] - 127);
            }*/

            // TODO: this takes 12 clock cycles
        } else {
            // TODO: this takes 8 clock cycles
        }

        return null;
    }

    /**
     * OP code 0x21 - Load immediate 16 bits into HL register.
     * @param ops The immediate 16 bits.
     */
    Void ld_hl_xx(int[] ops) {
        this.setHL(this.combineBytes(ops[0], ops[1]));
        return null;
    }

    /**
     * OP code 0x22 - Load A into the memory address pointed to by HL and then increment HL by 1.
     * @param ops unused.
     */
    Void ldi_hlp_a(int[] ops) {
        this.memory.setByteAt(this.getHL(), this.A);
        this.setHL(this.getHL() + 1);
        return null;
    }

    /**
     * OP code 0x23 - Increment HL by 1.
     * @param ops unused.
     */
    Void inc_hl(int[] ops) {
        this.setHL(this.getHL() + 1);
        return null;
    }

    /**
     * OP code 0x24 - Increment H by 1.
     * @param ops unused.
     */
    Void inc_h(int[] ops) {
        this.H = this.increment(this.H);
        return null;
    }

    /**
     * OP code 0x25 - Decrement H by 1.
     * @param ops unused.
     */
    Void dec_h(int[] ops) {
        this.H = this.decrement(this.H);
        return null;
    }

    /**
     * OP code 0x26 - Load immediate byte into H.
     * @param ops An 8 bit immediate value.
     */
    Void ld_h_x(int[] ops) {
        this.H = ops[0];
        return null;
    }

    /**
     * OP code 0x27 - When performing addition and subtraction, binary coded decimal (BCD) representation is
     * used to set the contents of register A to a BCD number.
     * @param ops unused
     */
    Void daa(int[] ops) {
        // after an addition, adjust A if a HALF_CARRY or CARRY occurred or if the result is out of bounds.
        if(!this.areFlagsSet(CPU.FLAG_ZERO)) {
            if(this.areFlagsSet(CPU.FLAG_CARRY) || this.A > 0x99) {
                this.A = (this.A + 0x60) & 0xFF;
                this.setFlags(CPU.FLAG_CARRY);
            }

            if(this.areFlagsSet(CPU.FLAG_HALF) || (this.A & 0x0F) > 0x09) {
                this.A = (this.A + 0x06) & 0xFF;
            }
        } else {
            // after a subtraction, only adjust if a HALF_CARRY or CARRY occurred.
            if(this.areFlagsSet(CPU.FLAG_CARRY)) {
                this.A -= 0x60;
            }

            if(this.areFlagsSet(CPU.FLAG_HALF)) {
                this.A -= 0x06;
            }
        }

        // set zero flag if A register is zero.
        if(this.A == 0) {
            this.setFlags(CPU.FLAG_ZERO);
        }

        // half carry always reset.
        this.setFlags(CPU.FLAG_HALF);

        return null;
    }

    /**
     * OP code 0x28 - Jump to given address relative to the current address if the zero flag is set.
     * @param ops The 8-bit offset
     */
    Void jr_z_x(int[] ops) {
        if((this.F & FLAG_ZERO) == FLAG_ZERO) {
            this.incrementPC((byte)ops[0]);

            // TODO: do I need to do this instead?
            /*if(ops[0] > 126) {
                this.incrementPC((ops[0] + 1) - 127);
            } else {
                this.incrementPC(ops[0] - 127);
            }*/

            // TODO: this takes 12 clock cycles
        } else {
            // TODO: this takes 8 clock cycles
        }

        return null;
    }

    /**
     * OP code 0x29 - Add HL to HL and store the value in HL.
     * @param ops unused.
     */
    Void add_hl_hl(int[] ops) {
        this.setHL(this.add16Bit(this.getHL(), this.getHL()));
        return null;
    }

    /**
     * OP code 0x2A - Load the value in memory pointed to by HL into A, then increment HL by 1.
     * @param ops unused.
     */
    Void ldi_a_hlp(int[] ops) {
        this.A = this.memory.getByteAt(this.getHL());
        this.setHL(this.getHL() + 1);
        return null;
    }

    /**
     * OP code 0x2B - Decrement HL by 1.
     * @param ops unused.
     */
    Void dec_hl(int[] ops) {
        this.setHL(this.getHL() - 1);
        return null;
    }

    /**
     * OP code 0x2C - Increment L by 1.
     * @param ops unused.
     */
    Void inc_l(int[] ops) {
        this.L = this.increment(this.L);
        return null;
    }

    /**
     * OP code 0x2D - Decrement L by 1.
     * @param ops unused.
     */
    Void dec_l(int[] ops) {
        this.L = this.decrement(this.L);
        return null;
    }

    /**
     * OP code 0x2E - Load immediate byte into L.
     * @param ops An 8 bit immediate value.
     */
    Void ld_l_x(int[] ops) {
        this.L = ops[0];
        return null;
    }

    /**
     * OP code 0x2F - Take the one's compliment of A and store the result in A.
     * @param ops unused.
     */
    Void cpl(int[] ops) {
        this.A = (~this.A) & 0xFF;
        return null;
    }

    /**
     * OP code 0x3E - Load immediate byte into A.
     * @param ops An 8 bit immediate value.
     */
    Void ld_a_x(int[] ops) {
        this.A = ops[0];
        return null;
    }
}
