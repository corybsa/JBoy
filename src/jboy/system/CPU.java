package jboy.system;

import jboy.other.CpuInfo;

import java.time.Instant;
import java.util.ArrayList;
import java.util.HashMap;

/**
 * <h3>Description</h3>
 * <h5>The GameBoy uses a chip that's a cross between the Intel 8080 and the Zilog Z80. The chip is the Sharp LR35902.</h5>
 *
 * <hr/>
 * <h3>Information about the CPU</h3>
 * <ul>
 *     <li>Number of instructions: 500</li>
 *     <li>
 *         Registers
 *         <ul>
 *             <li>8-bit: A, B, C, D, E, F, H, L</li>
 *             <li>16-bit: AF, BC, DE, HL, SP, PC</li>
 *         </ul>
 *     </li>
 *     <li>Clock speed: 4.194304 MHz (4.19 MHz)</li>
 * </ul>
 *
 * <hr/>
 * <h3>A few notes on the CPU:</h3>
 * <ul>
 *     <li>Official Nintendo documents refer to "machine cycles" when describing instructions.</li>
 *     <li>One machine cycle equals four CPU clock cycles.</li>
 *     <li>The numerical value of a machine cycle is 1.048576 MHz (1.05 MHz)</li>
 * </ul>
 *
 * <hr/>
 * <h3>A few notes on the registers:</h3>
 * <ul>
 *     <li>The F register is indirectly accessible by the programmer, and is used to store the results of various math operations.</li>
 *     <li>The PC register points to the next instruction to be executed in memory.</li>
 *     <li>The SP register points to the current stack position.</li>
 *     <li>
 *         The F register consists of the following:
 *         <ul>
 *             <li>Zero flag (Z, 7th bit): This bit is set when the result of a math operation is zero or two values match when using the CP instruction.</li>
 *             <li>Subtract flag (N, 6th bit): This bit is set if a subtraction was performed in the last math instruction regardless of result..</li>
 *             <li>Half carry flag (H, 5th bit): This bit is set if a carry occurred from the lower nibble in the last math operation.</li>
 *             <li>Carry flag (C, 4th bit): This bit is set when an operation results in carrying from or borrowing to the 7th bit.</li>
 *         </ul>
 *     </li>
 *     <li>
 *         On power up, the PC is initialized to 0x100 and the instruction at that location in the ROM is executed.
 *         From here on the PC is controlled indirectly by the instructions themselves that were generated by the programmer of the ROM cart.
 *     </li>
 *     <li>
 *         The SP is used to keep track of the top of the stack.
 *         <ul>
 *             <li>The Stack is used for saving variables, saving return addressed, passing arguments to subroutines and various other uses.</li>
 *             <li>The instructions CALL, PUSH and RST all put information onto the stack.</li>
 *             <li>The instructions POP, RET and RETI all take information off of the stack.</li>
 *             <li>Interrupts put a return address on the stack and remove it at the completion as well.</li>
 *             <li>
 *                 As information is put onto the stack, the stack grows DOWNWARD in RAM. As a result SP should always be initialized at the highest location of RAM space that has been allocated for use by the stack.
 *                 <ul>
 *                     <li>
 *                         For example, if a programmer wants to locate the SP at the top of low RAM space (0xC000 - 0xDFFF) he would set SP to 0xE000 using LD SP,0xE000.
 *                         (The SP automatically decrements before it puts something onto the stack, so it is perfectly acceptable to assign it a value which points to a memory address which is one location past the end of available RAM.)
 *                     </li>
 *                     <li>The SP is initialized to 0xFFFE on power up, but a programmer should not rely on this setting and should explicitly set its value.</li>
 *                 </ul>
 *             </li>
 *         </ul>
 *     </li>
 * </ul>
 */
public class CPU {
    // The frequency of the clock in MHz.
    public static final int FREQUENCY = 4194304;

    public static class Flags {
        public static int ZERO =  0b10000000;
        public static int SUB =   0b01000000;
        public static int HALF =  0b00100000;
        public static int CARRY = 0b00010000;
    }

    public Registers registers;

    private boolean isRunning = false;

    private boolean ime = false;
    private boolean pendingEnableIME = false;

    private boolean isStopped = false;

    public boolean isHalted = false;
    public boolean haltBug = false;
    public boolean haltSkip = false;
    public boolean justHalted = false;

    public long cycles = 0;
    private long cyclesSinceLastSync = 0;
    private long lastSyncTime = 0;

    private final Memory memory;
    private final GPU gpu;
    private final Timers timers;

    private final CpuInfo info;
    private final ArrayList<Integer> breakpoints;

    public CPU(Memory memory, GPU gpu, Timers timers) {
        this.registers = new Registers();
        this.memory = memory;
        this.gpu = gpu;
        this.timers = timers;
        this.info = new CpuInfo(this);
        this.breakpoints = new ArrayList<>();

        this.reset();
    }

    /**
     * Sets registers to default values.
     */
    public void reset() {
        this.isRunning = false;

        this.registers.setAF(0x01B0);
        this.registers.setBC(0x0013);
        this.registers.setDE(0x00D8);
        this.registers.setHL(0x014D);
        this.registers.SP = 0xFFFE;
        this.registers.PC = 0x100;
        this.cycles = 0;
        this.cyclesSinceLastSync = 0;
        this.lastSyncTime = 0;
        this.ime = false;
        this.pendingEnableIME = false;
        this.isHalted = false;
        this.haltBug = false;
        this.haltSkip = false;

        this.memory.setByteAt(IORegisters.TIMA, 0x00);
        this.memory.setByteAt(IORegisters.TMA, 0x00);
        this.memory.setByteAt(IORegisters.TAC, 0x00);
        this.memory.setByteAt(IORegisters.INTERRUPT_FLAGS, 0xE1);
        this.memory.setByteAt(IORegisters.SOUND1_SWEEP, 0x80);
        this.memory.setByteAt(IORegisters.SOUND1_LENGTH_WAVE, 0xBF);
        this.memory.setByteAt(IORegisters.SOUND1_ENVELOPE, 0xF3);
        this.memory.setByteAt(IORegisters.SOUND1_HIGH_FREQUENCY, 0xBF);
        this.memory.setByteAt(IORegisters.SOUND2_LENGTH_WAVE, 0x3F);
        this.memory.setByteAt(IORegisters.SOUND2_ENVELOPE, 0x00);
        this.memory.setByteAt(IORegisters.SOUND2_HIGH_FREQUENCY, 0xBF);
        this.memory.setByteAt(IORegisters.SOUND3_ENABLE, 0x7F);
        this.memory.setByteAt(IORegisters.SOUND3_LENGTH, 0xFF);
        this.memory.setByteAt(IORegisters.SOUND3_OUTPUT_LEVEL, 0x9F);
        this.memory.setByteAt(IORegisters.SOUND3_FREQUENCY_HIGH_DATA, 0xBF);
        this.memory.setByteAt(IORegisters.SOUND4_LENGTH, 0xFF);
        this.memory.setByteAt(IORegisters.SOUND4_ENVELOPE, 0x00);
        this.memory.setByteAt(IORegisters.SOUND4_COUNTER, 0x00);
        this.memory.setByteAt(IORegisters.SOUND4_INITIAL, 0xBF);
        this.memory.setByteAt(IORegisters.SOUND_CHANNEL_CONTROL, 0x77);
        this.memory.setByteAt(IORegisters.SOUND_OUTPUT_CONTROL, 0xF3);
        this.memory.setByteAt(IORegisters.SOUND_ENABLE, 0xF1);
        this.memory.setByteAt(IORegisters.LCDC, 0x91);
        this.memory.setByteAt(IORegisters.LCD_STATUS, 0x80);
        this.memory.setByteAt(IORegisters.SCROLL_Y, 0x00);
        this.memory.setByteAt(IORegisters.SCROLL_X, 0x00);
        this.memory.setByteAt(IORegisters.LY_COMPARE, 0x00);
        this.memory.setByteAt(IORegisters.BG_PALETTE_DATA, 0xFC);
        this.memory.setByteAt(IORegisters.OBJECT_PALETTE0_DATA, 0xFF);
        this.memory.setByteAt(IORegisters.OBJECT_PALETTE1_DATA, 0xFF);
        this.memory.setByteAt(IORegisters.WINDOW_Y, 0x00);
        this.memory.setByteAt(IORegisters.WINDOW_X, 0x00);
        this.memory.setByteAt(IORegisters.INTERRUPT_ENABLE, 0x00);

        this.gpu.reset();
        this.timers.reset();
    }

    /**
     * Tick one clock cycle
     */
    public void tick() {
        if(this.isStopped) {
            /*
            * the only way to exit stop mode is with the joypad
            */

            /*
            SAMEBOY CODE FOR STOP MODE

            if (gb->stopped) {
                GB_timing_sync(gb);  // this.synchronize()
                GB_advance_cycles(gb, 4);
                if ((gb->io_registers[GB_IO_JOYP] & 0xF) != 0xF) { // LISTEN FOR JOYPAD INTERRUPTS
                    leave_stop_mode(gb);
                    GB_advance_cycles(gb, 8);
                }
                return;
            }

            static void leave_stop_mode(GB_gameboy_t *gb)
            {
                // The CPU takes more time to wake up then the other components
                for (unsigned i = 0x200; i--;) {
                    GB_advance_cycles(gb, 0x10);
                }
                gb->stopped = false;
                gb->oam_ppu_blocked = false;
                gb->vram_ppu_blocked = false;
                gb->cgb_palettes_ppu_blocked = false;
            }

            */

            /*
            MY (OLD) CODE FOR STOP MODE.
            NEED JOYPAD SUPPORT
            this.gpu.tick(this.cycles);

            if((ie & flags & 0x1F) != 0) {
                this.isStopped = false;
            }

            // the GameBoy takes another 4 clock cycles to dispatch events when halted.
            this.incrementCycles(4);
            return;

            */
        }

        // Set cycles to 0 every frame to prevent integer overflow.
        if(this.cycles >= (CPU.FREQUENCY / Display.FREQUENCY)) {
            this.cycles = 0;
        }

        this.synchronize();

        // check if the last instruction was ei.
        if(this.pendingEnableIME) {
            this.ime = true;
            this.pendingEnableIME = false;
        }

        // Check if there are any interrupts that need to be serviced.
        boolean shouldServiceInterrupts = (this.getIF() & this.getIE()) != 0;

        if(this.isHalted && !this.justHalted) {
            this.incrementCycles(2);
        }

        if(this.isHalted) {
            this.incrementCycles(this.justHalted ? 4 : 2);
        }

        this.justHalted = false;

        if(this.isHalted && !this.ime && shouldServiceInterrupts) {
            this.isHalted = false;
        } else if(this.ime && shouldServiceInterrupts) {
            this.isHalted = false;
            this.checkInterrupts();
        } else {
            this.decode(this.memory.getByteAt(this.registers.PC++));
            this.gpu.tick(this.cycles);
        }

        /*if(this.isHalted && this.ime && shouldServiceInterrupts) {
            this.isHalted = false;

            if(!this.haltSkip) {
                this.checkInterrupts();
            }
        } else {
            if(shouldServiceInterrupts) {
                this.checkInterrupts();
            } else {
                this.decode(this.memory.getByteAt(this.registers.PC++));
                this.gpu.tick(this.cycles);
            }
        }*/
    }

    /**
     * The main loop. This ticks the CPU and runs forever.
     */
    void run() {
        this.isRunning = true;

        while(this.isRunning) {
            if(!this.breakpoints.isEmpty() && this.breakpoints.contains(this.registers.PC)) {
                break;
            }

            this.tick();
        }
    }

    /**
     * Sets flags in the F register. If multiple flags should be set, then they should be bitwise or'd together.
     * Example: if Z and H should be set, then they should be passed in to this method like this: Z | H
     * @param flags The flags to check.
     */
    public void setFlags(int flags) {
        this.registers.F = (this.registers.F | flags) & 0xF0;
    }

    /**
     * Resets flags in the F register. If multiple flags should be reset, then they should be bitwise or'd together.
     * Example: if Z and H should be reset, then they should be passed in to this method like this: Z | H
     * @param flags The flags to check.
     */
    public void resetFlags(int flags) {
        this.registers.F = (this.registers.F & ~flags) & 0xF0;
    }

    /**
     * Keeps the CPU from running as fast as it can. This will keep the frame rate at 60 fps.
     */
    private void synchronize() {
        // Our target sleep time is the length in time the previous instruction took.
        long target = (this.cyclesSinceLastSync * 75000L) / CPU.FREQUENCY;

        // Get the current nanoseconds since 1970.
        long nanoseconds = Instant.now().getEpochSecond() * 75000L;

        // The sleep duration is the previous instruction time plus how long it's been since we last synced.
        // We subtract the nanoseconds to see if the CPU is running too fast.
        // If sleepDuration is positive that means that the CPU is running incredibly fast (for GameBoy standards, anyway),
        //   and we need to slow it down by sleeping.
        long sleepDuration = target + this.lastSyncTime - nanoseconds;

        // There's a weird lag during vblank, so we can disable sleep during vblank
        //   and just process everything as fast as possible to mitigate the lag.
        // This is probably not the best solution, but it works.
        if(this.gpu.getMode() == GPU.Mode.VBLANK) {
            sleepDuration = 0;
        }

        // Check if sleepDuration is between zero and the time it takes to complete a whole frame.
        if(sleepDuration > 0 && sleepDuration < ((Display.LCDC_PERIOD * 75000L) / CPU.FREQUENCY)) {
            this.sleep(sleepDuration);

            // Need to keep track of how long it's been since we last synced.
            this.lastSyncTime += target;
        } else {
            // we need to know when we last synced.
            this.lastSyncTime = nanoseconds;
        }

        // We only care about the previous instruction, so we can set this to zero and it will be updated
        // after the next instruction is executed.
        this.cyclesSinceLastSync = 0;
    }

    /**
     * Sleep for {@code duration} nanoseconds.
     * @param duration Time in nanoseconds to sleep.
     */
    private void sleep(long duration) {
        try {
            if(duration > 999999) {
                Thread.sleep(0, 999999);
                this.sleep(duration - 999999);
            } else {
                Thread.sleep(0, (int)duration);
            }
        } catch(InterruptedException e) {
            // if sleep is interrupted, I don't think it matters.
        }
    }

    /**
     * Increments PC by specified amount.
     * @param n The amount to increment PC.
     */
    private void incrementPC(int n) {
        this.registers.PC += n;
    }

    /**
     * Keep track of how many cycles have elapsed and also keeps track of how many cycles since the components were last synced.
     * @param n The amount of machine cycles to increment by.
     */
    private void incrementCycles(int n) {
        this.cycles += n;
        this.cyclesSinceLastSync += n;
        this.timers.tick(n);
    }

    /**
     * Check for the 5 different hardware interrupts and service them as needed. They are serviced in order of priority.
     * The priority is as follows:
     * VBLANK, LCD Status, Timer overflow, Serial input, JoyPad input
     */
    private void checkInterrupts() {
        // TODO: interrupts are not working properly. Run blargg on bgb and compare.
        int enabledInterrupts = this.getIE() & this.getIF();

        if((enabledInterrupts & Interrupts.VBLANK) == Interrupts.VBLANK) {
            this.serviceInterrupt(Interrupts.VBLANK, 0x40);
        } else if((enabledInterrupts & Interrupts.LCD_STAT) == Interrupts.LCD_STAT) {
            this.serviceInterrupt(Interrupts.LCD_STAT, 0x48);
        } else if((enabledInterrupts & Interrupts.TIMER) == Interrupts.TIMER) {
            this.serviceInterrupt(Interrupts.TIMER, 0x50);
        } else if((enabledInterrupts & Interrupts.SERIAL) == Interrupts.SERIAL) {
            this.serviceInterrupt(Interrupts.SERIAL, 0x58);
        } else if((enabledInterrupts & Interrupts.JOYPAD) == Interrupts.JOYPAD) {
            this.serviceInterrupt(Interrupts.JOYPAD, 0x60);
        } else {
            this.timers.tick(4);
        }
    }

    /**
     * Servicing an interrupt disabled interrupts, resumes the CPU if it was stopped,
     * resets the interrupt bit that was serviced, resets the PC to a certain address
     * and consumes 5 cycles.
     * @param interrupt The {@link Interrupts interrupt} to service.
     * @param vector The address to reset to.
     */
    private void serviceInterrupt(int interrupt, int vector) {
        this.memory.setByteAt(IORegisters.INTERRUPT_FLAGS, this.getIF() & ~interrupt);

        // The IME is really a flag saying "enable/disable jumps to interrupt vectors."
        if(this.ime) {
            this.rst(vector);
        }

        this.ime = false;

        // The GameBoy takes 20 clock cycles to dispatch an interrupt
        this.incrementCycles(20);
    }

    /**
     * Decode op code to find out which instruction to execute.
     * @param opCode The op code to decode
     */
    private void decode(int opCode) {
        if(this.haltBug) {
            this.registers.PC--;
            this.haltBug = false;
        }

        if(opCode != 0xCB) {
            int x = opCode >> 6;
            int y = (opCode & 0b00111000) >> 3;
            int z = opCode & 0b00000111;
            int p = y >> 1;
            int q = y % 2;

            switch(x) {
                case 0b00:
                    this.doMiscOperation(y, z, q, p);
                    break;
                case 0b01:
                    this.doLoadOperation(y, z);
                    break;
                case 0b10:
                    this.doMathOperation(y, z);
                    break;
                case 0b11:
                    this.doJumpOperation(y, z, q, p);
                    break;
            }
        } else {
            this.decodeCB(this.memory.getByteAt(this.registers.PC++));
        }
    }

    /**
     * Decode CB-prefixed op code to find out which instruction to execute.
     * @param opCode The op code to decode
     */
    private void decodeCB(int opCode) {
        int x = opCode >> 6;
        int y = (opCode & 0b00111000) >> 3;
        int z = opCode & 0b00000111;

        switch(x) {
            case 0b00:
                switch(y) {
                    case 0b000: // rlc
                        if(z != 0b110) { // rlc [b, c, d, e, h, l,, a]
                            this.registers.set8BitRegister(z, this.rlc(this.registers.get8BitRegister(z)));
                        } else { // rlc (hl)
                            this.memory.setByteAt(this.registers.getHL(), this.rlc(this.memory.getByteAt(this.registers.getHL())));
                        }

                        break;
                    case 0b001: // rrc
                        if(z != 0b110) { // rrc [b, c, d, e, h, l,, a]
                            this.registers.set8BitRegister(z, this.rrc(this.registers.get8BitRegister(z)));
                        } else { // rrc (hl)
                            this.memory.setByteAt(this.registers.getHL(), this.rrc(this.memory.getByteAt(this.registers.getHL())));
                        }

                        break;
                    case 0b010: // rl
                        if(z != 0b110) { // rl [b, c, d, e, h, l,, a]
                            this.registers.set8BitRegister(z, this.rl(this.registers.get8BitRegister(z)));
                        } else { // rl (hl)
                            this.memory.setByteAt(this.registers.getHL(), this.rl(this.memory.getByteAt(this.registers.getHL())));
                        }

                        break;
                    case 0b011: // rr
                        if(z != 0b110) { // rr [b, c, d, e, h, l,, a]
                            this.registers.set8BitRegister(z, this.rr(this.registers.get8BitRegister(z)));
                        } else { // rr (hl)
                            this.memory.setByteAt(this.registers.getHL(), this.rr(this.memory.getByteAt(this.registers.getHL())));
                        }

                        break;
                    case 0b100: // sla
                        if(z != 0b110) { // sla [b, c, d, e, h, l,, a]
                            this.registers.set8BitRegister(z, this.sla(this.registers.get8BitRegister(z)));
                        } else { // sla (hl)
                            this.memory.setByteAt(this.registers.getHL(), this.sla(this.memory.getByteAt(this.registers.getHL())));
                        }

                        break;
                    case 0b101: // sra
                        if(z != 0b110) { // sra [b, c, d, e, h, l,, a]
                            this.registers.set8BitRegister(z, this.sra(this.registers.get8BitRegister(z)));
                        } else { // sra (hl)
                            this.memory.setByteAt(this.registers.getHL(), this.sra(this.memory.getByteAt(this.registers.getHL())));
                        }

                        break;
                    case 0b110: // swap
                        if(z != 0b110) { // swap [b, c, d, e, h, l,, a]
                            this.registers.set8BitRegister(z, this.swap(this.registers.get8BitRegister(z)));
                        } else { // swap (hl)
                            this.memory.setByteAt(this.registers.getHL(), this.swap(this.memory.getByteAt(this.registers.getHL())));
                        }

                        break;
                    case 0b111: // srl
                        if(z != 0b110) { // srl [b, c, d, e, h, l,, a]
                            this.registers.set8BitRegister(z, this.srl(this.registers.get8BitRegister(z)));
                        } else { // srl (hl)
                            this.memory.setByteAt(this.registers.getHL(), this.srl(this.memory.getByteAt(this.registers.getHL())));
                        }

                        break;
                }

                break;
            case 0b01: // bit
                if(z != 0b110) { // bit  [0, 1, 2, 3, 4, 5, 6, 7] [b, c, d, e, h, l, a]
                    this.bit(y, this.registers.get8BitRegister(z));
                } else { // bit  [0, 1, 2, 3, 4, 5, 6, 7] (hl)
                    this.bit(y, this.memory.getByteAt(this.registers.getHL()));
                }

                break;
            case 0b10: // res
                if(z != 0b110) { // res  [0, 1, 2, 3, 4, 5, 6, 7] [b, c, d, e, h, l, a]
                    this.registers.set8BitRegister(z, this.res(y, this.registers.get8BitRegister(z)));
                } else { // res  [0, 1, 2, 3, 4, 5, 6, 7] (hl)
                    this.memory.setByteAt(this.registers.getHL(), this.res(y, this.memory.getByteAt(this.registers.getHL())));
                }

                break;
            case 0b11: // set
                if(z != 0b110) { // set  [0, 1, 2, 3, 4, 5, 6, 7] [b, c, d, e, h, l, a]
                    this.registers.set8BitRegister(z, this.set(y, this.registers.get8BitRegister(z)));
                } else { // set  [0, 1, 2, 3, 4, 5, 6, 7] (hl)
                    this.memory.setByteAt(this.registers.getHL(), this.set(y, this.memory.getByteAt(this.registers.getHL())));
                }

                break;
        }

        // all CB-prefixed op codes have the same size and cycle duration.
        if(z != 0b110) {
            this.incrementCycles(8);
        } else {
            this.incrementCycles(16);
        }
    }

    /**
     * Perform various operations.
     * @param y Bits 5-3 of the op code
     * @param z Bits 7-6 of the op code
     * @param q Bit 3 of the op code
     * @param p Bits 5-4 of the op code
     */
    private void doMiscOperation(int y, int z, int q, int p) {
        switch(z) {
            case 0b000: // relative jumps and assorted ops
                switch(y) {
                    case 0b000: // nop
                        this.incrementCycles(4);
                        break;
                    case 0b001: // ld (xx), sp
                        this.memory.setByteAt(this.getWord(), this.registers.SP);
                        this.incrementCycles(20);
                        this.incrementPC(2);
                        break;
                    case 0b010: // stop
                        this.stop();
                        this.incrementCycles(4);
                        this.incrementPC(1);
                        break;
                    case 0b011: // jr x
                        this.jumpRelative(this.getByte());
                        this.incrementCycles(12);
                        break;
                    case 0b100: // jr nz x
                        if ((this.registers.F & Flags.ZERO) != Flags.ZERO) {
                            this.jumpRelative(this.getByte());
                            this.incrementCycles(12);
                        } else {
                            this.incrementCycles(8);
                            this.incrementPC(1);
                        }

                        break;
                    case 0b101: // jr z x
                        if ((this.registers.F & Flags.ZERO) == Flags.ZERO) {
                            this.jumpRelative(this.getByte());
                            this.incrementCycles(12);
                        } else {
                            this.incrementCycles(8);
                            this.incrementPC(1);
                        }

                        break;
                    case 0b110: // jr nc x
                        if ((this.registers.F & Flags.CARRY) != Flags.CARRY) {
                            this.jumpRelative(this.getByte());
                            this.incrementCycles(12);
                        } else {
                            this.incrementCycles(8);
                            this.incrementPC(1);
                        }

                        break;
                    case 0b111: // jr c x
                        if ((this.registers.F & Flags.CARRY) == Flags.CARRY) {
                            this.jumpRelative(this.getByte());
                            this.incrementCycles(12);
                        } else {
                            this.incrementCycles(8);
                            this.incrementPC(1);
                        }

                        break;
                }

                break;
            case 0b001: // 16-bit immediate/add
                if(q == 0) {
                    // ld [bc, de, hl, sp], xx
                    this.registers.set16BitRegister(p, this.getWord(), false);
                    this.incrementCycles(12);
                    this.incrementPC(2);
                } else if(q == 1) {
                    this.registers.setHL(this.add16Bit(this.registers.getHL(), this.registers.get16BitRegister(p, false)));
                    this.incrementCycles(8);
                }

                break;
            case 0b010: // indirect loading
                if(q == 0) {
                    switch(p) {
                        case 0b00: // ld (bc), a
                            this.memory.setByteAt(this.registers.getBC(), this.registers.A);
                            break;
                        case 0b01: // ld (de), a
                            this.memory.setByteAt(this.registers.getDE(), this.registers.A);
                            break;
                        case 0b10: // ld (hl+), a
                            this.memory.setByteAt(this.registers.getHL(), this.registers.A);
                            this.registers.setHL(this.registers.getHL() + 1);
                            break;
                        case 0b11: // ld (hl-), a
                            this.memory.setByteAt(this.registers.getHL(), this.registers.A);
                            this.registers.setHL(this.registers.getHL() - 1);
                            break;
                    }
                } else if(q == 1) {
                    switch(p) {
                        case 0b00: // ld a, (bc)
                            this.registers.A = this.memory.getByteAt(this.registers.getBC());
                            break;
                        case 0b01: // ld a, (de)
                            this.registers.A = this.memory.getByteAt(this.registers.getDE());
                            break;
                        case 0b10: // ld a, (hl+)
                            this.registers.A = this.memory.getByteAt(this.registers.getHL());
                            this.registers.setHL(this.registers.getHL() + 1);
                            break;
                        case 0b11: // ld a, (hl-)
                            this.registers.A = this.memory.getByteAt(this.registers.getHL());
                            this.registers.setHL(this.registers.getHL() - 1);
                            break;
                    }
                }

                this.incrementCycles(8);
                break;
            case 0b011: // 16-bit inc/dec
                if(q == 0) { // inc [bc, de, hl. sp]
                    this.registers.set16BitRegister(p, this.registers.get16BitRegister(p, false) + 1, false);
                } else if(q == 1) { // dec [bc, de, hl. sp]
                    this.registers.set16BitRegister(p, this.registers.get16BitRegister(p, false) - 1, false);
                }

                this.incrementCycles(8);
                break;
            case 0b100: // 8-bit inc/dec
                if(y == 0b110) { // inc (hl)
                    int value = this.increment(this.memory.getByteAt(this.registers.getHL()));
                    this.memory.setByteAt(this.registers.getHL(), value);
                    this.incrementCycles(8);
                } else { // inc [b, c, d, e, h, l, a]
                    this.registers.set8BitRegister(y, this.increment(this.registers.get8BitRegister(y)));
                    this.incrementCycles(4);
                }

                break;
            case 0b101: // 8-bit dec
                if(y == 0b110) { // dec (hl)
                    int value = this.decrement(this.memory.getByteAt(this.registers.getHL()));
                    this.memory.setByteAt(this.registers.getHL(), value);
                    this.incrementCycles(8);
                } else { // dec [b, c, d, e, h, l, a]
                    this.registers.set8BitRegister(y, this.decrement(this.registers.get8BitRegister(y)));
                    this.incrementCycles(4);
                }
                break;
            case 0b110: // ld [b, c, d, e, h, l, (hl), a], x
                if(y == 0b110) { // ld (hl), x
                    this.memory.setByteAt(this.registers.getHL(), this.getByte());
                } else {
                    this.registers.set8BitRegister(y, this.getByte());
                }

                this.incrementCycles(8);
                this.incrementPC(1);
                break;
            case 0b111: // assorted operations on accumulator/flags
                this.doLogicOperation(y);
                this.incrementCycles(4);
                break;
        }
    }

    /**
     * Perform various load operations.
     * @param y Bits 5-3 of the op code
     * @param z Bits 7-6 of the op code
     */
    private void doLoadOperation(int y, int z) {
        if(y == 0b110 && z == 0b110) { // halt
            this.halt();
            this.incrementCycles(4);
        } else if(y == z) { // nop
            this.incrementCycles(4);
        } else {
            if(z == 0b110) { // ld [b, c, d, e, h, l, a], (hl)
                this.registers.set8BitRegister(y, this.memory.getByteAt(this.registers.getHL()));
                this.incrementCycles(8);
            } else if(y == 0b110) { // ld (hl), [b, c, d, e, h, l, a]
                this.memory.setByteAt(this.registers.getHL(), this.registers.get8BitRegister(z));
                this.incrementCycles(8);
            } else { // ld [b, c, d, e, h, l, a], [b, c, d, e, h, l, a]
                this.registers.set8BitRegister(y, this.registers.get8BitRegister(z));
                this.incrementCycles(4);
            }
        }
    }

    /**
     * Perform math operations: add, adc, sub, sbc, and, xor, or, cp
     * @param y Bits 5-3 of the op code
     * @param z Bits 7-6 of the op code
     */
    private void doMathOperation(int y, int z) {
        switch(y) {
            case 0b000: // add
                if(z != 0b110) { // add a, [b, c, d, e, h, l, a]
                    this.registers.A = this.add8Bit(this.registers.A, this.registers.get8BitRegister(z));
                    this.incrementCycles(4);
                } else { // add a, (hl)
                    this.registers.A = this.add8Bit(this.registers.A, this.memory.getByteAt(this.registers.getHL()));
                    this.incrementCycles(8);
                }

                break;
            case 0b001: // adc
                if(z != 0b110) { // adc a, [b, c, d, e, h, l, a]
                    this.registers.A = this.adc(this.registers.A, this.registers.get8BitRegister(z));
                    this.incrementCycles(4);
                } else { // adc a, (hl)
                    this.registers.A = this.adc(this.registers.A, this.memory.getByteAt(this.registers.getHL()));
                    this.incrementCycles(8);
                }

                break;
            case 0b010: // sub
                if(z != 0b110) { // sub a, [b, c, d, e, h, l, a]
                    this.registers.A = this.sub(this.registers.A, this.registers.get8BitRegister(z));
                    this.incrementCycles(4);
                } else { // sub a, (hl)
                    this.registers.A = this.sub(this.registers.A, this.memory.getByteAt(this.registers.getHL()));
                    this.incrementCycles(8);
                }

                break;
            case 0b011: // sbc
                if(z != 0b110) { // sbc a, [b, c, d, e, h, l, a]
                    this.registers.A = this.sbc(this.registers.A, this.registers.get8BitRegister(z));
                    this.incrementCycles(4);
                } else { // sbc a, (hl)
                    this.registers.A = this.sbc(this.registers.A, this.memory.getByteAt(this.registers.getHL()));
                    this.incrementCycles(8);
                }

                break;
            case 0b100: // and
                if(z != 0b110) { // and a, [b, c, d, e, h, l, a]
                    this.registers.A = this.and(this.registers.A, this.registers.get8BitRegister(z));
                    this.incrementCycles(4);
                } else { // and a, (hl)
                    this.registers.A = this.and(this.registers.A, this.memory.getByteAt(this.registers.getHL()));
                    this.incrementCycles(8);
                }

                break;
            case 0b101: // xor
                if(z != 0b110) { // xor a, [b, c, d, e, h, l, a]
                    this.registers.A = this.xor(this.registers.A, this.registers.get8BitRegister(z));
                    this.incrementCycles(4);
                } else { // xor a, (hl)
                    this.registers.A = this.xor(this.registers.A, this.memory.getByteAt(this.registers.getHL()));
                    this.incrementCycles(8);
                }

                break;
            case 0b110: // or
                if(z != 0b110) { // or a, [b, c, d, e, h, l, a]
                    this.registers.A = this.or(this.registers.A, this.registers.get8BitRegister(z));
                    this.incrementCycles(4);
                } else { // or a, (hl)
                    this.registers.A = this.or(this.registers.A, this.memory.getByteAt(this.registers.getHL()));
                    this.incrementCycles(8);
                }

                break;
            case 0b111: // cp
                if(z != 0b110) { // cp a, [b, c, d, e, h, l, a]
                    this.cp(this.registers.A, this.registers.get8BitRegister(z));
                    this.incrementCycles(4);
                } else { // cp a, (hl)
                    this.cp(this.registers.A, this.memory.getByteAt(this.registers.getHL()));
                    this.incrementCycles(8);
                }

                break;
        }
    }

    /**
     * Perform jump, call and ret operations.
     * @param y Bits 5-3 of the op code
     * @param z Bits 7-6 of the op code
     * @param q Bit 3 of the op code
     * @param p Bits 5-4 of the op code
     */
    private void doJumpOperation(int y, int z, int q, int p) {
        int high = this.memory.getByteAt(this.registers.SP + 1);
        int low = this.memory.getByteAt(this.registers.SP);

        switch(z) {
            case 0b000: // conditional return
                switch(y) {
                    case 0b000: // ret nz
                        if((this.registers.F & Flags.ZERO) != Flags.ZERO) {
                            this.registers.PC = this.combineBytes(high, low);
                            this.registers.SP += 2;
                            this.incrementCycles(20);
                        } else {
                            this.incrementCycles(8);
                        }

                        break;
                    case 0b001: // ret z
                        if((this.registers.F & Flags.ZERO) == Flags.ZERO) {
                            this.registers.PC = this.combineBytes(high, low);
                            this.registers.SP += 2;
                            this.incrementCycles(20);
                        } else {
                            this.incrementCycles(8);
                        }

                        break;
                    case 0b010: // ret nc
                        if((this.registers.F & Flags.CARRY) != Flags.CARRY) {
                            this.registers.PC = this.combineBytes(high, low);
                            this.registers.SP += 2;
                            this.incrementCycles(20);
                        } else {
                            this.incrementCycles(8);
                        }

                        break;
                    case 0b011: // ret c
                        if((this.registers.F & Flags.CARRY) == Flags.CARRY) {
                            this.registers.PC = this.combineBytes(high, low);
                            this.registers.SP += 2;
                            this.incrementCycles(20);
                        } else {
                            this.incrementCycles(8);
                        }

                        break;
                    case 0b100: // ld (x), a
                        this.memory.setByteAt(0xFF00 + this.getByte(), this.registers.A);
                        this.incrementCycles(12);
                        this.incrementPC(1);

                        break;
                    case 0b101: // add sp, x
                        this.registers.SP = this.add16Bit(this.registers.SP, this.getByte());
                        this.setFlags(Flags.ZERO);
                        this.incrementCycles(16);
                        this.incrementPC(1);

                        break;
                    case 0b110: // ld a, (x)
                        this.registers.A = this.memory.getByteAt(0xFF00 + this.getByte());
                        this.incrementCycles(12);
                        this.incrementPC(1);

                        break;
                    case 0b111: // ld hl sp+x
                        int op = this.getByte();
                        int result = this.registers.SP + op;

                        if((result & 0xFFFF0000) != 0) {
                            this.setFlags(Flags.CARRY);
                        } else {
                            this.resetFlags(Flags.CARRY);
                        }

                        if(((this.registers.SP & 0x0F) + (op & 0x0F)) > 0x0F) {
                            this.setFlags(Flags.HALF);
                        } else {
                            this.resetFlags(Flags.HALF);
                        }

                        this.resetFlags(Flags.ZERO | Flags.SUB);
                        this.registers.setHL(result & 0xFFFF);
                        this.incrementCycles(12);
                        this.incrementPC(1);

                        break;
                }

                break;
            case 0b001: // pop & various ops
                if(q == 0) { // pop [bc, de, hl, af]
                    this.registers.set16BitRegister(p, this.combineBytes(high, low), true);
                    this.registers.SP += 2;
                    this.incrementCycles(12);
                } else if(q == 1) {
                    switch(p) {
                        case 0b00: // ret
                            this.registers.PC = this.combineBytes(high, low);
                            this.registers.SP += 2;
                            this.incrementCycles(16);

                            break;
                        case 0b01: // reti
                            this.registers.PC = this.combineBytes(high, low);
                            this.registers.SP += 2;
                            this.ime = true;
                            this.incrementCycles(16);

                            break;
                        case 0b10: // jp hl
                            this.registers.PC = this.registers.getHL();
                            this.incrementCycles(4);

                            break;
                        case 0b11: // ld sp, hl
                            this.registers.SP = this.registers.getHL();
                            this.incrementCycles(8);

                            break;
                    }
                }

                break;
            case 0b010: // conditional jump
                if((p >> 1) == 0) {
                    switch(y) {
                        case 0b000: // jp nz xx
                            if((this.registers.F & Flags.ZERO) != Flags.ZERO) {
                                this.registers.PC = this.getWord() - 2;
                                this.incrementCycles(16);
                            } else {
                                this.incrementCycles(12);
                            }

                            break;
                        case 0b001: // jp z xx
                            if((this.registers.F & Flags.ZERO) == Flags.ZERO) {
                                this.registers.PC = this.getWord() - 2;
                                this.incrementCycles(16);
                            } else {
                                this.incrementCycles(12);
                            }

                            break;
                        case 0b010: // jp nc xx
                            if((this.registers.F & Flags.CARRY) != Flags.CARRY) {
                                this.registers.PC = this.getWord() - 2;
                                this.incrementCycles(16);
                            } else {
                                this.incrementCycles(12);
                            }

                            break;
                        case 0b011: // jp c xx
                            if((this.registers.F & Flags.CARRY) == Flags.CARRY) {
                                this.registers.PC = this.getWord() - 2;
                                this.incrementCycles(16);
                            } else {
                                this.incrementCycles(12);
                            }

                            break;
                    }

                    this.incrementPC(2);
                } else {
                    switch(y) {
                        case 0b100: // ld (c), a
                            this.memory.setByteAt(0xFF00 + (this.registers.C & 0xFF), this.registers.A);
                            this.incrementCycles(8);

                            break;
                        case 0b101: // ld (xx), a
                            this.memory.setByteAt(this.getWord(), this.registers.A);
                            this.incrementCycles(16);
                            this.incrementPC(2);

                            break;
                        case 0b110: // ld a, (c)
                            this.registers.A = this.memory.getByteAt(0xFF00 + (this.registers.C & 0xFF));
                            this.incrementCycles(8);

                            break;
                        case 0b111: // ld a, (xx)
                            this.registers.A = this.memory.getByteAt(this.getWord());
                            this.incrementCycles(16);
                            this.incrementPC(2);

                            break;
                    }
                }

                break;
            case 0b011: // assorted operations
                switch(y) {
                    case 0b000: // jp xx
                        this.registers.PC = this.getWord() - 2;
                        this.incrementCycles(16);
                        this.incrementPC(2);

                        break;
                    case 0b001: // cb-prefixed operations. do nothing
                        break;
                    case 0b010: // nop
                    case 0b011: // nop
                    case 0b100: // nop
                    case 0b101: // nop
                        this.incrementCycles(4);

                        break;
                    case 0b110: // di
                        // DI immediately disables the IME and cancels any pending enabled caused by EI
                        this.ime = false;
                        this.pendingEnableIME = false;
                        this.incrementCycles(4);

                        break;
                    case 0b111: // ei
                        // EI takes an extra cycle for the IME to be enabled
                        this.pendingEnableIME = true;
                        this.incrementCycles(4);

                        break;
                }

                break;
            case 0b100: // conditional calls
                switch(y) {
                    case 0b000: // call nz xx
                        if((this.registers.F & Flags.ZERO) != Flags.ZERO) {
                            this.call();
                        } else {
                            this.incrementCycles(12);
                            this.incrementPC(2);
                        }

                        break;
                    case 0b001: // call z xx
                        if((this.registers.F & Flags.ZERO) == Flags.ZERO) {
                            this.call();
                        } else {
                            this.incrementCycles(12);
                            this.incrementPC(2);
                        }

                        break;
                    case 0b010: // call nc xx
                        if((this.registers.F & Flags.CARRY) != Flags.CARRY) {
                            this.call();
                        } else {
                            this.incrementCycles(12);
                            this.incrementPC(2);
                        }

                        break;
                    case 0b011: // call c xx
                        if((this.registers.F & Flags.CARRY) == Flags.CARRY) {
                            this.call();
                        } else {
                            this.incrementCycles(12);
                            this.incrementPC(2);
                        }

                        break;
                    case 0b100: // nop
                    case 0b101: // nop
                    case 0b110: // nop
                    case 0b111: // nop
                        this.incrementCycles(4);

                        break;
                }

                break;
            case 0b101: // push & various ops
                if(q == 0) { // push [bc, de, hl, af]
                    this.memory.setByteAt(this.registers.SP - 1, (this.registers.get16BitRegister(p, true) >> 8) & 0xFF);
                    this.memory.setByteAt(this.registers.SP - 2, (this.registers.get16BitRegister(p, true)) & 0xFF);
                    this.registers.SP -= 2;
                    this.incrementCycles(16);
                } else if(q == 1) {
                    if(p == 0) { // call xx
                        this.call();
                    } else { // nop
                        this.incrementCycles(4);
                    }
                }

                break;
            case 0b110: // operate on accumulator and immediate operand
                switch(y) {
                    case 0b000: // add a, x
                        this.registers.A = this.add8Bit(this.registers.A, this.getByte());

                        break;
                    case 0b001: // adc a, x
                        this.registers.A = this.adc(this.registers.A, this.getByte());

                        break;
                    case 0b010: // sub a, x
                        this.registers.A = this.sub(this.registers.A, this.getByte());

                        break;
                    case 0b011: // sbc a, x
                        this.registers.A = this.sbc(this.registers.A, this.getByte());

                        break;
                    case 0b100: // and a, x
                        this.registers.A = this.and(this.registers.A, this.getByte());

                        break;
                    case 0b101: // xor a, x
                        this.registers.A = this.xor(this.registers.A, this.getByte());

                        break;
                    case 0b110: // or a, x
                        this.registers.A = this.or(this.registers.A, this.getByte());

                        break;
                    case 0b111: // adc a, x
                        this.cp(this.registers.A, this.getByte());

                        break;
                }

                this.incrementCycles(8);
                this.incrementPC(1);

                break;
            case 0b111: // reset
                this.rst(y * 8);
                this.incrementCycles(16);

                break;
        }
    }

    /**
     * Perform logic operations: rlca, rrca, rla, rra, daa, cpl, scf, ccf
     * @param y Bits 5-3 of the op code
     */
    private void doLogicOperation(int y) {
        switch(y) {
            case 0b000: // rlca
                this.rlca();
                break;
            case 0b001: // rrca
                this.rrca();
                break;
            case 0b010: // rla
                this.rla();
                break;
            case 0b011: // rra
                this.rra();
                break;
            case 0b100: // daa
                this.daa();
                break;
            case 0b101: // cpl
                this.cpl();
                break;
            case 0b110: // scf
                this.scf();
                break;
            case 0b111: // ccf
                this.ccf();
                break;
        }
    }

    /**
     * Perform a relative jump. Increments PC by the amount of the next byte (between -128 and 127)
     */
    private void jumpRelative(int op) {
        if(op <= 127) {
            this.incrementPC(op);
        } else {
            this.incrementPC((256 - op) * -1);
        }
    }

    /**
     * Store current PC on the stack and redirect PC to the called address.
     */
    private void call() {
        this.memory.setByteAt(this.registers.SP - 1, ((this.registers.PC + 2) >> 8) & 0xFF);
        this.memory.setByteAt(this.registers.SP - 2, ((this.registers.PC + 2)) & 0xFF);
        this.registers.PC = this.getWord();
        this.registers.SP -= 2;
        this.incrementCycles(24);
    }

    /**
     * Get the next byte from memory.
     * @return The next byte in memory.
     */
    private int getByte() {
        return this.memory.getByteAt(this.registers.PC);
    }

    /**
     * Get the next 2 bytes from memory. The GameBoy is Little Endian so the high byte and the low byte
     * are the second and first bytes from the current location, respectively.
     * @return The next 2 bytes in memory.
     */
    private int getWord() {
        return this.combineBytes(
                this.memory.getByteAt(this.registers.PC + 1),
                this.memory.getByteAt(this.registers.PC)
        );
    }

    /**
     * Combines two bytes. Example, 0xC0 + 0xDE = 0xC0DE
     * @param highByte The value that the upper byte should equal.
     * @param lowByte The value that the lower byte should equal.
     * @return The sum of the bytes.
     */
    private int combineBytes(int highByte, int lowByte) {
        return (highByte << 8) + lowByte;
    }

    /**
     * Gets the value of the interrupt flag.
     * @return The value at memory address 0xFF0F
     */
    public int getIF() {
        return this.memory.getByteAt(IORegisters.INTERRUPT_FLAGS);
    }

    /**
     * Gets the value of the interrupt enable.
     * @return The value at memory address 0xFFFF
     */
    public int getIE() {
        return this.memory.getByteAt(IORegisters.INTERRUPT_ENABLE);
    }

    /**
     * Reads the state of the interrupt master enable (IME).
     * @return The state of the IME.
     */
    public boolean getIME() {
        return this.ime;
    }

    public void addBreakpoint(int breakpoint) {
        this.breakpoints.add(breakpoint);
    }

    public void removeBreakpoint(int breakpoint) {
        this.breakpoints.remove(breakpoint);
    }

    public ArrayList<Integer> getBreakpoints() {
        return this.breakpoints;
    }

    /**
     * Increments a {@code value} by 1 and sets the necessary flags.
     * @param value The value to increment.
     * @return The incremented value.
     */
    private int increment(int value) {
        // Flags.HALF - set if there was a carry from the 3rd bit to the 4th bit, otherwise reset.
        if((value & 0x0F) == 0x0F) {
            this.setFlags(Flags.HALF);
        } else {
            this.resetFlags(Flags.HALF);
        }

        // increment value by 1 and get the first 8 bits
        value = (value + 1) & 0xFF;

        // Flags.SUB - reset
        this.resetFlags(Flags.SUB);

        // Flags.ZERO - set if result is 0, otherwise reset
        if(value == 0) {
            this.setFlags(Flags.ZERO);
        } else {
            this.resetFlags(Flags.ZERO);
        }

        return value;
    }

    /**
     * Decrements a {@code value} by 1 and sets the necessary flags.
     * @param value The value to decrement.
     * @return The decremented value.
     */
    private int decrement(int value) {
        // decrement value by 1 and get the first 8 bits
        int result = (value - 1) & 0xFF;

        // Flags.HALF - set if there was a carry (borrow) from the 4th bit to the 3rd bit, otherwise reset.
        // invert value's bits, xor with (value - 1) then find out what the 4th bit is with (& 0x10).
        // If it equals zero, then there was a carry.
        if((((~value) ^ (result)) & 0x10) == 0) {
            this.setFlags(Flags.HALF);
        } else {
            this.resetFlags(Flags.HALF);
        }

        value = result;

        // Flags.SUB - set
        this.setFlags(Flags.SUB);

        // Flags.ZERO - set if result is 0, otherwise reset
        if(value == 0) {
            this.setFlags(Flags.ZERO);
        } else {
            this.resetFlags(Flags.ZERO);
        }

        return value;
    }

    /**
     * Adds two 16-bit numbers together and sets the necessary flags.
     * @param num1 The first number.
     * @param num2 The second number.
     * @return The 16-bit result of the addition.
     */
    private int add16Bit(int num1, int num2) {
        int result = num1 + num2;

        if((result & 0xFFFF0000) != 0) {
            this.setFlags(Flags.CARRY);
        } else {
            this.resetFlags(Flags.CARRY);
        }

        if(((num1 & 0x0F00) + (num2 & 0x0F00)) > 0x0F00) {
            this.setFlags(Flags.HALF);
        } else {
            this.resetFlags(Flags.HALF);
        }

        this.resetFlags(Flags.SUB);
        return result & 0xFFFF;
    }

    /**
     * Adds two 8-bit numbers together and sets the necessary flags.
     * @param num1 The first number.
     * @param num2 The second number.
     * @return The 8-bit result of the addition.
     */
    private int add8Bit(int num1, int num2) {
        int result = num1 + num2;

        if((result & 0xFF00) != 0) {
            this.setFlags(Flags.CARRY);
        } else {
            this.resetFlags(Flags.CARRY);
        }

        if((result & 0xFF) != 0) {
            this.resetFlags(Flags.ZERO);
        } else {
            this.setFlags(Flags.ZERO);
        }

        if(((num1 & 0x0F) + (num2 & 0x0F)) > 0x0F) {
            this.setFlags(Flags.HALF);
        } else {
            this.resetFlags(Flags.HALF);
        }

        this.resetFlags(Flags.SUB);
        return result & 0xFF;
    }

    /**
     * Adds two 8-bit numbers with the current value of the carry flag and sets the necessary flags.
     * @param num1 The first number.
     * @param num2 The second number.
     * @return The 8-bit result of the addition.
     */
    private int adc(int num1, int num2) {
        int carry = (this.registers.F & Flags.CARRY) >> 4;
        int result = num1 + num2 + carry;

        if((result & 0xFF00) != 0) {
            this.setFlags(Flags.CARRY);
        } else {
            this.resetFlags(Flags.CARRY);
        }

        if((result & 0xFF) != 0) {
            this.resetFlags(Flags.ZERO);
        } else {
            this.setFlags(Flags.ZERO);
        }

        if(((num1 & 0x0F) + (num2 & 0x0F) + carry) > 0x0F) {
            this.setFlags(Flags.HALF);
        } else {
            this.resetFlags(Flags.HALF);
        }

        this.resetFlags(Flags.SUB);
        return result & 0xFF;
    }

    /**
     * Subtracts {@code num2} from {@code num1} and sets the necessary flags.
     * @param num1 The value to subtract from.
     * @param num2 The value to subtract.
     * @return The 8-bit result of the subtraction.
     */
    private int sub(int num1, int num2) {
        if(num2 > num1) {
            this.setFlags(Flags.CARRY);
        } else {
            this.resetFlags(Flags.CARRY);
        }

        if((num2 & 0x0F) > (num1 & 0x0F)) {
            this.setFlags(Flags.HALF);
        } else {
            this.resetFlags(Flags.HALF);
        }

        int result = (num1 - num2) & 0xFF;

        if(result == 0) {
            this.setFlags(Flags.ZERO);
        } else {
            this.resetFlags(Flags.ZERO);
        }

        this.setFlags(Flags.SUB);

        return result;
    }

    /**
     * Subtracts {@code num2} and the current value of the carry flag from {@code num1} and sets the necessary flags.
     * @param num1 The value to subtract from.
     * @param num2 The value to subtract
     * @return The 8-bit result of the subtraction.
     */
    private int sbc(int num1, int num2) {
        int result = num1 - num2;
        result = result - ((this.registers.F & Flags.CARRY) >> 4);

        if(result < 0) {
            this.setFlags(Flags.CARRY);
        } else {
            this.resetFlags(Flags.CARRY);
        }

        result &= 0xFF;

        if(result == 0) {
            this.setFlags(Flags.ZERO);
        } else {
            this.resetFlags(Flags.ZERO);
        }

        if(((result ^ num2 ^ num1) & 0x10) == 0x10) {
            this.setFlags(Flags.HALF);
        } else {
            this.resetFlags(Flags.HALF);
        }

        this.setFlags(Flags.SUB);

        return result;
    }

    /**
     * Shifts {@code value} left, sets the carry flag and the 0th bit to the value of the 7th bit. Sets the necessary flags.
     * @param value The value to shift.
     * @return The shifted value.
     */
    private int rlc(int value) {
        // check the 7th bit of the value.
        if((value & 0x80) == 0x80) {
            this.setFlags(Flags.CARRY);
        } else {
            this.resetFlags(Flags.CARRY);
        }

        // subtraction and half carry flags are reset.
        this.resetFlags(Flags.SUB | Flags.HALF);

        // shift A left by 1 bit, change the 0th bit to whatever the carry flag was.
        int result = (((value << 1) & (~0x01)) | ((value & 0x80) >> 7)) & 0xFF;

        if(result == 0) {
            this.setFlags(Flags.ZERO);
        } else {
            this.resetFlags(Flags.ZERO);
        }

        return result;
    }

    /**
     * Shift A left by 1 bit. Carry flag is set to the 7th bit of A.
     */
    private void rlca() {
        int carry = (this.registers.A & 0x80) >> 7;

        if(carry == 1) {
            this.setFlags(Flags.CARRY);
        }

        // shift bit left by 1 and get the first 8 bits
        this.registers.A = (this.registers.A << 1) & 0xFF;

        // set the 0th bit to whatever was at the 7th bit.
        this.registers.A = this.registers.A | carry;

        this.resetFlags(Flags.ZERO | Flags.SUB | Flags.HALF);
    }

    /**
     * Shifts {@code value} right, sets the carry flag and the 7th bit to the value of the 0th bit. Sets the necessary flags.
     * @param value The value to shift.
     * @return The shifted value.
     */
    private int rrc(int value) {
        // check the 0th bit of the value.
        if((value & 0x01) == 0x01) {
            this.setFlags(Flags.CARRY);
        } else {
            this.resetFlags(Flags.CARRY);
        }

        // subtraction and half carry flags are reset.
        this.resetFlags(Flags.SUB | Flags.HALF);

        // shift A left by 1 bit, change the 0th bit to whatever the carry flag was.
        // (((0x01 >> 1) & (~0x01)) | ((0x01 & 0x01) << 7)) & 0xFF
        int result = (((value >> 1) & (~0x01)) | ((value & 0x01) << 7)) & 0xFF;

        if(result == 0) {
            this.setFlags(Flags.ZERO);
        } else {
            this.resetFlags(Flags.ZERO);
        }

        return result;
    }

    /**
     * Shift A right by 1 bit. Carry flag is set to the 0th bit of A.
     */
    private void rrca() {
        int carry = this.registers.A & 0x01;

        if(carry == 0x01) {
            this.setFlags(Flags.CARRY);
        } else {
            this.resetFlags(Flags.CARRY);
        }

        // set the 7th bit to whatever was at the 0th bit.
        this.registers.A = (((this.registers.A >> 1) & (~0x80)) | (carry << 7)) & 0xFF;

        this.resetFlags(Flags.ZERO | Flags.SUB | Flags.HALF);
    }

    /**
     * Shifts {@code value} left, sets the 0th bit to the value of the carry flag. Sets the necessary flags.
     * @param value The value to shift.
     * @return The shifted value.
     */
    private int rl(int value) {
        int carry = this.registers.F & Flags.CARRY;

        if((value & 0x80) == 0x80) {
            this.setFlags(Flags.CARRY);
        } else {
            this.resetFlags(Flags.CARRY);
        }

        int result = ((value << 1) | carry) & 0xFF;

        if(result == 0) {
            this.setFlags(Flags.ZERO);
        } else {
            this.resetFlags(Flags.ZERO);
        }

        return result;
    }

    /**
     * Shift A left by 1. The 0th bit of A is set to the value of the CARRY flag. CARRY flag is set to the 7th bit of A.
     */
    private void rla() {
        // get current state of carry flag.
        int carry = (this.registers.F & Flags.CARRY) >> 4;

        // check the 7th bit of A.
        if((this.registers.A & 0x80) == 0x80) {
            this.setFlags(Flags.CARRY);
        } else {
            this.resetFlags(Flags.CARRY);
        }

        // shift A left by 1 bit, change the 0th bit to whatever the carry flag was.
        this.registers.A = (((this.registers.A << 1) & (~0x01)) | carry) & 0xFF;

        // all other flags are reset.
        this.resetFlags(Flags.ZERO | Flags.SUB | Flags.HALF);
    }

    /**
     * Shifts {@code value} right, sets the 7th bit to the value of the carry flag. Sets the necessary flags.
     * @param value The value to shift.
     * @return The shifted value.
     */
    private int rr(int value) {
        int carry = this.registers.F & Flags.CARRY;

        if((value & 0x01) == 0x01) {
            this.setFlags(Flags.CARRY);
        } else {
            this.resetFlags(Flags.CARRY);
        }

        int result = ((value >> 1) | (carry << 7)) & 0xFF;

        if(result == 0) {
            this.setFlags(Flags.ZERO);
        } else {
            this.resetFlags(Flags.ZERO);
        }

        return result;
    }

    /**
     * Shift A right by 1. The 7th bit of A is set to the value of the CARRY flag. CARRY flag is set the 0th bit of A.
     */
    private void rra() {
        // get current state of carry flag.
        int carry = (this.registers.F & Flags.CARRY) >> 4;

        // check the 0th bit of A.
        if((this.registers.A & 0x01) == 0x01) {
            this.setFlags(Flags.CARRY);
        } else {
            this.resetFlags(Flags.CARRY);
        }

        // shift A right by 1 bit, change the 7th bit to whatever the carry flag was.
        this.registers.A = (((this.registers.A >> 1) & (~0x80)) | (carry << 7)) & 0xFF;

        // all other flags are reset.
        this.resetFlags(Flags.ZERO | Flags.SUB | Flags.HALF);
    }

    /**
     * Shifts {@code value} left, sets the carry flag to the value of the 7th bit, resets the 0th bit. Sets the necessary flags.
     * @param value The value to shift.
     * @return The shifted value.
     */
    private int sla(int value) {
        if((value & 0x80) == 0x80) {
            this.setFlags(Flags.CARRY);
        } else {
            this.resetFlags(Flags.CARRY);
        }

        int result = (value << 1) & 0xFF;

        if(result == 0) {
            this.setFlags(Flags.ZERO);
        } else {
            this.resetFlags(Flags.ZERO);
        }

        this.resetFlags(Flags.SUB | Flags.HALF);

        return result;
    }

    /**
     * Shifts {@code value} right, sets the carry flag to the value of the 0th bit, 7th bit is unchanged. Sets the necessary flags.
     * @param value The value to shift.
     * @return The shifted value.
     */
    private int sra(int value) {
        if((value & 0x01) == 0x01) {
            this.setFlags(Flags.CARRY);
        } else {
            this.resetFlags(Flags.CARRY);
        }

        int result = ((value >> 1) | (value & 0x80)) & 0xFF;

        if(result == 0) {
            this.setFlags(Flags.ZERO);
        } else {
            this.resetFlags(Flags.ZERO);
        }

        this.resetFlags(Flags.SUB | Flags.HALF);

        return result;
    }

    /**
     * Swaps the low and high nibbles.
     * @param value The value to swap.
     * @return The swapped value.
     */
    private int swap(int value) {
        int result = ((value & 0x0F) << 4) + (value >> 4);

        if(result == 0) {
            this.setFlags(Flags.ZERO);
        } else {
            this.resetFlags(Flags.ZERO);
        }

        this.resetFlags(Flags.SUB | Flags.HALF | Flags.CARRY);
        return result;
    }

    /**
     * Shifts {@code value} right, sets the carry flag to the value of the 0th bit, resets the 7th bit. Sets the necessary flags.
     * @param value The value to shift.
     * @return The shifted value.
     */
    private int srl(int value) {
        if((value & 0x01) == 0x01) {
            this.setFlags(Flags.CARRY);
        } else {
            this.resetFlags(Flags.CARRY);
        }

        int result = (value >> 1) & 0xFF;

        if(result == 0) {
            this.setFlags(Flags.ZERO);
        } else {
            this.resetFlags(Flags.ZERO);
        }

        this.resetFlags(Flags.SUB | Flags.HALF);

        return result;
    }

    /**
     * When performing addition and subtraction, binary coded decimal (BCD) representation is
     * used to set the contents of register A to a BCD number.
     */
    private void daa() {
        boolean sub = (this.registers.F & Flags.SUB) == Flags.SUB;
        boolean half = (this.registers.F & Flags.HALF) == Flags.HALF;
        boolean carry = (this.registers.F & Flags.CARRY) == Flags.CARRY;

        // after an addition, adjust A if a HALF_CARRY or CARRY occurred or if the result is out of bounds.
        if(!sub) {
            if(carry || this.registers.A > 0x99) {
                this.registers.A = (this.registers.A + 0x60) & 0xFF;
                this.setFlags(Flags.CARRY);
            }

            if(half || (this.registers.A & 0x0F) > 0x09) {
                this.registers.A = (this.registers.A + 0x06) & 0xFF;
            }
        } else {
            // after a subtraction, only adjust if a HALF_CARRY or CARRY occurred.
            if(carry) {
                this.registers.A = (this.registers.A - 0x60) & 0xFF;
            }

            if(half) {
                this.registers.A = (this.registers.A - 0x06) & 0xFF;
            }
        }

        // set zero flag if A register is zero.
        if(this.registers.A == 0) {
            this.setFlags(Flags.ZERO);
        } else {
            this.resetFlags(Flags.ZERO);
        }

        // half carry always reset.
        this.resetFlags(Flags.HALF);
    }

    /**
     * Take the one's compliment of A and store the result in A.
     */
    private void cpl() {
        this.registers.A = (~this.registers.A) & 0xFF;
        this.setFlags(Flags.SUB | Flags.HALF);
    }

    /**
     * Sets carry flag, resets half carry and subtraction flags.
     */
    private void scf() {
        this.setFlags(Flags.CARRY);
        this.resetFlags(Flags.SUB | Flags.HALF);
    }

    /**
     * Toggle the carry flag.
     */
    private void ccf() {
        int carry = ((~this.registers.F & 0xFF) & Flags.CARRY) >> 4;

        if(carry == 1) {
            this.setFlags(Flags.CARRY);
        } else {
            this.resetFlags(Flags.CARRY);
        }
    }

    /**
     * Copies the compliment of the specified bit at {@code position}. Sets the necessary flags.
     * @param position The bit to operate on.
     * @param value The value to operate on.
     */
    private void bit(int position, int value) {
        int result = ~(value >> position) & 0x01;

        if(result == 1) {
            this.setFlags(Flags.ZERO);
        } else {
            this.resetFlags(Flags.ZERO);
        }

        this.setFlags(Flags.HALF);
        this.resetFlags(Flags.SUB);
    }

    /**
     * Resets the bit at {@code position}.
     * @param position The bit to operate on.
     * @param value The value to operate on.
     * @return The value with the specified bit reset.
     */
    private int res(int position, int value) {
        return (value & ~(0x01 << position)) & 0xFF;
    }

    /**
     * Sets the bit at {@code position}.
     * @param position The bit to operate on.
     * @param value The value to operate on.
     * @return The value with the specified bit set.
     */
    private int set(int position, int value) {
        return ((value & ~(0x01 << position)) | (1 << position)) & 0xFF;
    }

    /**
     * Performs a bitwise and operation on {@code num1} and {@code num2}.
     * @param num1 The first value to bitwise AND with
     * @param num2 The second value to bitwise AND with
     * @return The the result of the bitwise AND.
     */
    private int and(int num1, int num2) {
        num1 &= num2;

        if(num1 == 0) {
            this.setFlags(Flags.ZERO);
        } else {
            this.resetFlags(Flags.ZERO);
        }

        this.resetFlags(Flags.SUB | Flags.CARRY);
        this.setFlags(Flags.HALF);

        return num1;
    }

    /**
     * Performs a bitwise xor operation on {@code num1} and {@code num2}.
     * @param num1 The first value to bitwise XOR with
     * @param num2 The second value to bitwise XOR with
     * @return The the result of the bitwise XOR.
     */
    private int xor(int num1, int num2) {
        num1 ^= num2;

        if(num1 == 0) {
            this.setFlags(Flags.ZERO);
        } else {
            this.resetFlags(Flags.ZERO);
        }

        this.resetFlags(Flags.SUB | Flags.HALF | Flags.CARRY);

        return num1;
    }

    /**
     * Performs a bitwise or operation on {@code num1} and {@code num2}.
     * @param num1 The first value to bitwise OR with
     * @param num2 The second value to bitwise OR with
     * @return The the result of the bitwise OR.
     */
    private int or(int num1, int num2) {
        num1 |= num2;

        if(num1 == 0) {
            this.setFlags(Flags.ZERO);
        } else {
            this.resetFlags(Flags.ZERO);
        }

        this.resetFlags(Flags.SUB | Flags.HALF | Flags.CARRY);

        return num1;
    }

    /**
     * Compares the contents of {@code num1} and {@code num2} and sets flags if they are equal.
     * @param num1 The first value to compare
     * @param num2 The second value to compare
     */
    private void cp(int num1, int num2) {
        if(num1 == num2) {
            this.setFlags(Flags.ZERO);
        } else {
            this.resetFlags(Flags.ZERO);
        }

        if((num1 & 0x0F) < (num2 & 0x0F)) {
            this.setFlags(Flags.HALF);
        } else {
            this.resetFlags(Flags.HALF);
        }

        if(num1 < num2) {
            this.setFlags(Flags.CARRY);
        } else {
            this.resetFlags(Flags.CARRY);
        }

        this.setFlags(Flags.SUB);
    }

    /**
     * Push PC onto stack and reset PC to {@code address}.
     * @param address The address to jump to.
     */
    private void rst(int address) {
        this.memory.setByteAt(this.registers.SP - 1, (this.registers.PC >> 8) & 0xFF);
        this.memory.setByteAt(this.registers.SP - 2, this.registers.PC & 0xFF);
        this.registers.SP -= 2;
        this.registers.PC = address;
    }

    /**
     * Stop the CPU.
     */
    private void stop() {
        this.isStopped = true;
    }

    /**
     * Halt the CPU.
     */
    private void halt() {
        int flags = this.getIF();
        int ie = this.getIE();

        if(this.ime) {
            /*
                HALT executed normally. CPU stops executing instructions until (IE & IF & 1F) != 0. When
                a flag in IF is set and the corresponding IE flag is also set, the CPU jumps to the interrupt
                vector. The return address pushed to the stack is the next instruction to the HALT, not the
                HALT itself. The IF flag corresponding to the vector the CPU has jumped in is cleared.
            */
            this.isHalted = true;
        } else {
            if((ie & flags & 0x1F) == 0) {
                /*
                    HALT mode is entered. It works like the IME = 1 case, but when an IF flag is set and
                    the corresponding IE flag is also set, the CPU doesn't jump to the interrupt vector, it
                    just continues executing instructions. The IF flags aren't cleared.
                */
                this.isHalted = true;
                this.haltSkip = true;
            } else {
                /*
                    HALT mode is not entered. HALT bug occurs: The CPU fails to increase PC when
                    executing the next instruction. The IF flags aren't cleared. This results in weird
                    behaviour.
                */
                this.isHalted = false;
                this.haltBug = true;
            }
        }

        this.justHalted = true;
    }
}
